<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AIDesigner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            background: #ffffff;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e1e4e8;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            color: #586069;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn.active {
            color: #0366d6;
            border-bottom-color: #0366d6;
            background: #ffffff;
        }

        .tab-btn:hover:not(.active) {
            color: #24292e;
            background: #f1f3f4;
        }

        /* Tab Content */
        .tab-content {
            flex: 1;
            display: none;
            padding: 16px;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        /* Common Elements */
        .section {
            margin-bottom: 20px;
        }

        .section h3 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #24292e;
        }

        .btn {
            background: #0366d6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover:not(:disabled) {
            background: #0256cc;
        }

        .btn:disabled {
            background: #8c959f;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #24292e;
            border: 1px solid #d1d5da;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f8f9fa;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            width: auto;
            margin: 0 4px 0 0;
        }
.platform-toggle-container {
  margin-bottom: 16px;
}

.toggle-label {
  display: block;
  font-weight: 600;
  font-size: 12px;
  margin-bottom: 8px;
  color: #374151;
}

.toggle-buttons {
  display: flex;
  gap: 8px;
}

.toggle-btn {
  flex: 1;
  padding: 8px 16px;
  border: 1px solid #d1d5db;
  background: white;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #6b7280;
}

.toggle-btn:hover {
  background: #f9fafb;
  border-color: #9ca3af;
}

.toggle-btn.active {
  background: #dbeafe;
  color: #1d4ed8;
  border-color: #3b82f6;
  font-weight: 600;
}
        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #24292e;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5da;
            border-radius: 4px;
            font-size: 12px;
            resize: vertical;
        }

        .input-group textarea {
            min-height: 80px;
        }

        /* Status Messages */
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 12px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Enhanced Component List */
        .stats-bar {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 11px;
        }

        .stat {
            color: #586069;
        }

        .stat-value {
            font-weight: 600;
            color: #24292e;
        }

        .filter-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .filter-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #d1d5da;
            border-radius: 3px;
            font-size: 11px;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 1px solid #d1d5da;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            color: #586069;
        }

        .filter-btn.active {
            background: #0366d6;
            color: white;
            border-color: #0366d6;
        }

        .component-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            min-height: 200px;
        }

        .component-item {
            padding: 12px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .component-item:hover {
            background: #f8f9fa;
        }

        .component-item:last-child {
            border-bottom: none;
        }

        .component-info {
            flex: 1;
            min-width: 0;
        }

        .component-name {
            font-weight: 600;
            font-size: 12px;
            color: #24292e;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .component-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .type-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
        }

        .type-select {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #d1d5da;
            border-radius: 3px;
            background: white;
            font-size: 11px;
            color: #586069;
            cursor: pointer;
        }

        .type-select:focus {
            border-color: #0366d6;
            box-shadow: 0 0 0 2px rgba(3, 102, 214, 0.2);
            outline: none;
        }

        .type-select option {
            padding: 4px 8px;
        }

        .confidence-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
            min-width: 35px;
            text-align: center;
        }

        .confidence-high {
            background: #d4edda;
            color: #155724;
        }

        .confidence-medium {
            background: #fff3cd;
            color: #856404;
        }

        .confidence-low {
            background: #f8d7da;
            color: #721c24;
        }

        .confidence-verified {
            background: #d1ecf1;
            color: #0c5460;
        }

        .component-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .btn-action {
            padding: 4px 8px;
            border: 1px solid #d1d5da;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            color: #586069;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background: #f8f9fa;
            border-color: #0366d6;
            color: #0366d6;
        }

        .page-info {
            font-size: 9px;
            color: #959da5;
            margin-left: 8px;
        }

        .status-icon {
            font-size: 10px;
            margin-right: 4px;
        }

        .icon-verified {
            color: #28a745;
        }

        .icon-auto {
            color: #0366d6;
        }

        .icon-unknown {
            color: #d73a49;
        }

        .context-bar {
            background: #f8f9fa;
            padding: 8px 16px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }

        .context-info {
            color: #586069;
        }

        .generation-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row .btn {
            margin-bottom: 0;
        }

        .scan-status {
            background: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .scan-status.loaded {
            background: #d4edda;
            border-color: #c3e6cb;
        }

        .scan-status-text {
            font-size: 11px;
            color: #24292e;
            margin-bottom: 8px;
        }

        .hidden {
            display: none;
        }
        
        .image-upload-area {
            border: 2px dashed #d1d5da;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s;
            margin-bottom: 16px;
        }

        .image-upload-area:hover {
            border-color: #0366d6;
        }

        .image-upload-area.has-image {
            border-style: solid;
            border-color: #28a745;
            padding: 10px;
        }

        .upload-prompt {
            color: #586069;
            font-size: 12px;
        }

        .image-preview {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        .image-preview button {
            margin-top: 8px;
        }

        .iteration-context {
            border: 1px solid #d1ecf1;
            background: #f1f8ff;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }
        .current-design-info h4 {
            font-size: 12px;
            font-weight: 600;
            color: #0366d6;
            margin: 0 0 8px 0;
        }
        .current-design-info h4 span {
            font-weight: 500;
            color: #24292e;
        }
        .modification-history {
            max-height: 80px;
            overflow-y: auto;
            font-size: 10px;
            color: #586069;
            margin-bottom: 10px;
            padding-left: 15px;
        }
        .modification-history li {
            margin-bottom: 4px;
        }
        .iteration-controls {
            display: flex;
            gap: 8px;
        }

        /* NEW: Session Modal Styles */
        .session-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .session-modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
        }

        .session-modal-content {
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 360px;
            width: calc(100% - 32px);
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .session-modal-header h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #24292e;
        }

        .session-modal-header p {
            margin: 0 0 16px 0;
            font-size: 12px;
            color: #586069;
        }

        .session-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .session-detail {
            margin-bottom: 8px;
            font-size: 11px;
        }

        .session-detail strong {
            color: #24292e;
            display: inline-block;
            min-width: 80px;
        }

        .session-detail span {
            color: #586069;
        }

        #sessionHistoryList {
            margin: 4px 0 0 0;
            padding-left: 16px;
            font-size: 10px;
            color: #586069;
            max-height: 60px;
            overflow-y: auto;
        }

        #sessionHistoryList li {
            margin-bottom: 2px;
        }

        .session-modal-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .session-modal-actions .btn {
            margin-bottom: 0;
        }

        .session-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .session-item {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .session-item:hover {
            background: #f8f9fa;
            border-color: #0366d6;
        }

        .session-item.current-file {
            border-color: #28a745;
            background: #f1f8ff;
        }

        .session-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .session-file-name {
            font-weight: 600;
            font-size: 12px;
            color: #24292e;
        }

        .session-time {
            font-size: 10px;
            color: #586069;
        }

        .session-item-details {
            font-size: 10px;
            color: #586069;
        }

        .session-item-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .session-item-actions .btn {
            padding: 4px 8px;
            font-size: 10px;
            margin: 0;
            flex: 1;
        }

        .current-file-badge {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
        }
        .toggle-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: #f3f4f6;
    color: #9ca3af;
}
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-nav">
        <button class="tab-btn active" onclick="switchTab('design-system')">🔍 Design System</button>
        <button class="tab-btn" onclick="switchTab('api-settings')">⚙️ API Settings</button>
        <button class="tab-btn" onclick="switchTab('ai-generator')" id="generatorTab" disabled>💬 AI Generator</button>
    </div>

    <!-- Session Restoration Modal -->
    <div class="session-modal" id="sessionModal" style="display: none;">
        <div class="session-modal-backdrop" onclick="closeSessionModal()"></div>
        <div class="session-modal-content">
            <div class="session-modal-header">
                <h3>🔄 Found Previous Work</h3>
                <p>There's unfinished design work in this file</p>
            </div>
            
            <div class="session-modal-body">
                <div class="session-info">
                    <div class="session-detail">
                        <strong>Frame:</strong> <span id="sessionFrameName"></span>
                    </div>
                    <div class="session-detail">
                        <strong>Last modified:</strong> <span id="sessionLastModified"></span>
                    </div>
                    <div class="session-detail">
                        <strong>History:</strong> 
                        <ul id="sessionHistoryList"></ul>
                    </div>
                </div>
            </div>
            
            <div class="session-modal-actions">
                <button class="btn" onclick="restoreSession()">📂 Continue Work</button>
                <button class="btn btn-secondary" onclick="startNewSession()">🗂️ Start Fresh</button>
                <button class="btn btn-secondary btn-small" onclick="showAllSessions()">👁️ All Sessions</button>
            </div>
        </div>
    </div>

    <!-- All Sessions Modal -->
    <div class="session-modal" id="allSessionsModal" style="display: none;">
        <div class="session-modal-backdrop" onclick="closeAllSessionsModal()"></div>
        <div class="session-modal-content">
            <div class="session-modal-header">
                <h3>📁 All Active Sessions</h3>
                <p>Select a session to view or manage</p>
            </div>
            
            <div class="session-modal-body">
                <div class="session-list" id="allSessionsList">
                    <!-- Dynamically generated by JS -->
                </div>
            </div>
            
            <div class="session-modal-actions">
                <button class="btn btn-secondary" onclick="closeAllSessionsModal()">❌ Close</button>
            </div>
        </div>
    </div>

    <!-- Tab 1: Design System -->
    <div class="tab-content active" id="design-system">
        <div class="scan-status" id="scanStatusContainer">
            <div class="scan-status-text" id="scanStatusText">No design system scanned yet</div>
            <button class="btn btn-secondary btn-small" onclick="rescanDesignSystem()" id="rescanBtn" style="display: none;">🔄 Re-scan</button>
        </div>

        <div class="section">
            <h3>Scan Components</h3>
            <button class="btn" onclick="scanDesignSystem()" id="scanBtn">🔍 Scan Design System</button>
        </div>

        <div class="section" id="componentsSection" style="display: none;">
            <h3>Found Components</h3>
            
            <div class="stats-bar" id="statsBar">
                <div class="stat">Total: <span class="stat-value" id="totalCount">0</span></div>
                <div class="stat">High confidence: <span class="stat-value" id="highConfCount">0</span></div>
                <div class="stat">Need review: <span class="stat-value" id="lowConfCount">0</span></div>
                <div class="stat">Verified: <span class="stat-value" id="verifiedCount">0</span></div>
            </div>

            <div class="filter-bar">
                <input type="text" class="filter-input" placeholder="Search components..." id="searchInput">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="unknown">Unknown</button>
                <button class="filter-btn" data-filter="low">Low Conf</button>
                <button class="filter-btn" data-filter="verified">Verified</button>
            </div>
            
            <div class="component-list" id="componentsList"></div>
        </div>

        <div class="section" id="promptSection" style="display: none;">
            <h3>LLM Prompt</h3>
            <button class="btn btn-secondary" onclick="generateLLMPrompt()">📋 Generate & Copy Prompt</button>
        </div>
    </div>

    <!-- Tab 2: API Settings -->
    <div class="tab-content" id="api-settings">
        <div class="section">
            <h3>Gemini API Configuration</h3>
            <div class="input-group">
                <label for="apiKey">API Key:</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key">
            </div>
            <button class="btn" onclick="saveApiKey()" id="saveBtn">💾 Save API Key</button>
        </div>

        <div class="section">
            <h3>Connection Test</h3>
            <button class="btn btn-secondary" onclick="testGeminiConnection()" id="testBtn">🔌 Test Connection</button>
            <div id="connectionStatus"></div>
        </div>

        <div class="section">
            <h3>Debug Options</h3>
            <button class="btn btn-secondary btn-small" onclick="clearAllData()">🗑️ Clear All Data</button>
        </div>
    </div>

    <!-- Tab 3: AI Generator -->
    <div class="tab-content" id="ai-generator">
        <div class="context-bar" id="contextBar">
            <span class="context-info" id="currentContext">Ready for new UI</span>
            <button class="btn btn-secondary btn-small" onclick="startFresh()" id="resetBtn">🗂️ New UI</button>
        </div>

        <!-- Iteration Context Area -->
        <div class="iteration-context" id="iterationContext" style="display: none;">
            <div class="current-design-info">
                <h4>Modifying: <span id="currentDesignName"></span></h4>
                <ul class="modification-history" id="modHistory">
                    <li>Original design generated.</li>
                </ul>
            </div>
            <div class="iteration-controls">
                <button class="btn btn-secondary btn-small" onclick="viewCurrentDesignJSON()">👁️ View Current JSON</button>
                <button class="btn btn-secondary btn-small" onclick="resetToOriginal()">↩️ Reset to Original</button>
            </div>
        </div>
    <!-- INSERT PLATFORM TOGGLE HERE -->
    <div class="platform-toggle-container">
        <label class="toggle-label">Platform:</label>
        <div class="toggle-buttons">
            <button id="mobile-toggle" class="toggle-btn active" data-platform="mobile" onclick="setActivePlatform('mobile')">
                📱 Mobile
            </button>
            <button id="desktop-toggle" class="toggle-btn" data-platform="desktop" disabled>
                🖥️ Desktop <span style="font-size: 9px; opacity: 0.7;">(Soon)</span>
            </button>
        </div>
    </div>
    <!-- END PLATFORM TOGGLE -->
        <!-- Image Upload Section -->
        <div class="section">
            <h3>Reference Image (Optional)</h3>
            <div class="image-upload-area" id="imageUploadArea">
                <input type="file" id="imageInput" accept="image/jpeg, image/png, image/webp, image/gif" style="display: none;">
                <div class="upload-prompt" id="uploadPrompt">
                    📷 Click to upload or drag & drop a reference image
                </div>
                <div class="image-preview" id="imagePreview" style="display: none;">
                    <img id="previewImg" style="max-width: 100%; max-height: 150px; border-radius: 4px;">
                    <button class="btn btn-secondary btn-small" onclick="clearImageSelection()">❌ Remove Image</button>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="generation-area">
                <div class="input-group">
                    <label for="userPrompt" id="userPromptLabel">Describe the UI you want to create:</label>
                    <textarea id="userPrompt" placeholder="create a login form with email and password fields..."></textarea>
                </div>
                
                <div class="button-row">
                    <button class="btn" onclick="generateWithGemini()" id="generateBtn">🪄 Generate UI</button>
                </div>
            </div>
        </div>

        <div id="generationStatus"></div>

        <!-- JSON Debug Section -->
        <div class="section" id="jsonDebugSection" style="display: none;">
            <h3>Generated JSON</h3>
            <div class="button-row">
                <button class="btn btn-secondary btn-small" onclick="copyGeneratedJSON()">📋 Copy JSON</button>
                <button class="btn btn-secondary btn-small" onclick="toggleJSONView()">👁️ Show/Hide</button>
            </div>
            <pre id="jsonOutput" style="display: none; background: #f6f8fa; border: 1px solid #d1d5da; border-radius: 4px; padding: 12px; font-size: 11px; overflow-x: auto; max-height: 300px; overflow-y: auto; font-family: 'Monaco', 'Consolas', monospace;"></pre>
        </div>

        <!-- Manual JSON input as fallback -->
        <div class="section" style="margin-top: 32px; border-top: 1px solid #e1e4e8; padding-top: 16px;">
            <h3>Manual Mode (Fallback)</h3>
            <div class="input-group">
                <label for="jsonInput">Paste JSON directly:</label>
                <textarea id="jsonInput" placeholder='{"layoutContainer": {...}, "items": [...]}'></textarea>
            </div>
            <button class="btn btn-secondary" onclick="generateFromJSON()">📄 Generate from JSON</button>
        </div>
    </div>

    <!-- Load pattern intelligence before main script -->
    <script src="component-patterns.js"></script>
    
    <!-- Prompt generator will be loaded from the modular system -->
    
    <!-- Embedded working functions for immediate functionality -->
    <script>
        console.log('🚀 HTML Script executing...');
        
        // Basic tab switching that works immediately
        window.switchTab = function(tabId) {
            console.log('✅ Tab switching to:', tabId);
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            const targetBtn = document.querySelector(`[onclick*="${tabId}"]`);
            const targetContent = document.getElementById(tabId);
            
            if (targetBtn) targetBtn.classList.add('active');
            if (targetContent) targetContent.classList.add('active');
        };
        
        // Platform toggle
        window.setActivePlatform = function(platform) {
            console.log('✅ Platform switched to:', platform);
            
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const platformBtn = document.getElementById(platform + '-toggle');
            if (platformBtn) {
                platformBtn.classList.add('active');
            }
        };
        
        // API Key functionality
        window.saveApiKey = function() {
            console.log('💾 Save API Key called');
            
            const apiKeyInput = document.getElementById('apiKey');
            const saveBtn = document.getElementById('saveBtn');
            const statusContainer = document.getElementById('connectionStatus');
            
            if (!apiKeyInput || !saveBtn) {
                console.error('❌ API key elements not found');
                return;
            }
            
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                showStatus('❌ Please enter an API key', 'error');
                return;
            }
            
            // Update UI
            saveBtn.disabled = true;
            saveBtn.textContent = '💾 Saving...';
            
            // Send to Figma backend
            parent.postMessage({
                pluginMessage: {
                    type: 'save-api-key',
                    payload: apiKey
                }
            }, '*');
            
            // Response will be handled by message listener
        };
        
        window.testGeminiConnection = function() {
            console.log('🔌 Test Connection called');
            
            const testBtn = document.getElementById('testBtn');
            const apiKeyInput = document.getElementById('apiKey');
            
            if (!testBtn) return;
            
            // Quick validation of API key format
            const apiKey = apiKeyInput?.value?.trim();
            if (apiKey && !apiKey.includes('●')) {
                if (!apiKey.startsWith('AIza')) {
                    showStatus('❌ Invalid API key format. Gemini API keys should start with "AIza"', 'error');
                    return;
                }
                if (apiKey.length < 35) {
                    showStatus('❌ API key too short. Should be around 39 characters', 'error');
                    return;
                }
            }
            
            testBtn.disabled = true;
            testBtn.textContent = '🔌 Testing...';
            showStatus('🔄 Testing API connection...', 'info');
            
            // Send test request to backend
            parent.postMessage({
                pluginMessage: {
                    type: 'test-api-connection'
                }
            }, '*');
            
            // Reset button after timeout
            setTimeout(() => {
                if (testBtn.disabled) {
                    testBtn.disabled = false;
                    testBtn.textContent = '🔌 Test Connection';
                    showStatus('⏰ Test timed out - check Figma console for details', 'error');
                }
            }, 10000);
        };
        
        // Status display function
        function showStatus(message, type = 'info') {
            const statusContainer = document.getElementById('connectionStatus');
            if (statusContainer) {
                statusContainer.innerHTML = `<div class="status ${type}">${message}</div>`;
                
                // Auto-clear success messages
                if (type === 'success') {
                    setTimeout(() => {
                        statusContainer.innerHTML = '';
                    }, 5000);
                }
            }
        }
        
        // Handle design system scan results
        function handleScanResults(components, scanTime) {
            console.log('📊 Processing scan results:', components?.length || 0);
            
            // Debug: Log first few components to see structure
            if (components && components.length > 0) {
                console.log('🔍 Sample component structure:', components[0]);
                console.log('🔍 All component types found:', components.map(c => ({
                    name: c.name,
                    suggestedType: c.suggestedType,
                    type: c.type,
                    componentType: c.componentType,
                    category: c.category
                })));
            }
            
            // Reset scan button
            const scanBtn = document.getElementById('scanBtn');
            if (scanBtn) {
                scanBtn.disabled = false;
                scanBtn.textContent = '🔍 Scan Design System';
            }
            
            // Update status
            const statusContainer = document.getElementById('scanStatusContainer');
            const statusText = document.getElementById('scanStatusText');
            const rescanBtn = document.getElementById('rescanBtn');
            const componentsSection = document.getElementById('componentsSection');
            const promptSection = document.getElementById('promptSection');
            
            if (components && components.length > 0) {
                // Show success status
                if (statusContainer) statusContainer.classList.add('loaded');
                if (statusText) {
                    const timeAgo = scanTime ? getTimeAgo(scanTime) : 'just now';
                    statusText.textContent = `✅ ${components.length} components loaded (scanned ${timeAgo})`;
                }
                if (rescanBtn) rescanBtn.style.display = 'inline-block';
                
                // Show components section
                if (componentsSection) componentsSection.style.display = 'block';
                if (promptSection) promptSection.style.display = 'block';
                
                // Update stats
                updateComponentStats(components);
                
                // Display components
                displayComponents(components);
                
                // Set up filter button listeners
                setupFilterButtons();
                
                // Set up search input listener
                setupSearchInput();
                
                showStatus(`✅ Found ${components.length} components in your design system!`, 'success');
            } else {
                showStatus('❌ No components found. Make sure you have a design system with components.', 'error');
            }
        }
        
        // Update component statistics
        function updateComponentStats(components) {
            const totalCount = document.getElementById('totalCount');
            const highConfCount = document.getElementById('highConfCount');
            const lowConfCount = document.getElementById('lowConfCount');
            const verifiedCount = document.getElementById('verifiedCount');
            
            const stats = {
                total: components.length,
                highConf: components.filter(c => c.confidence >= 0.8).length,
                lowConf: components.filter(c => c.confidence < 0.5).length,
                verified: components.filter(c => c.isVerified).length
            };
            
            if (totalCount) totalCount.textContent = stats.total;
            if (highConfCount) highConfCount.textContent = stats.highConf;
            if (lowConfCount) lowConfCount.textContent = stats.lowConf;
            if (verifiedCount) verifiedCount.textContent = stats.verified;
        }
        
        // Store scan results globally for filtering
        let globalScanResults = [];
        let currentFilter = 'all';
        
        // Display component list
        function displayComponents(components, filter = 'all') {
            const componentsList = document.getElementById('componentsList');
            if (!componentsList) return;
            
            // Store components globally
            globalScanResults = components;
            currentFilter = filter;
            
            // Filter components based on selected filter
            const filteredComponents = filterComponents(components, filter);
            
            componentsList.innerHTML = filteredComponents.map(component => `
                <div class="component-item">
                    <div class="component-info">
                        <div class="component-name">${component.name}</div>
                        <div class="component-meta">
                            <span class="confidence-badge confidence-${getConfidenceLevel(component.confidence)}">
                                ${Math.round(component.confidence * 100)}%
                            </span>
                            <span class="type-selector">
                                <select class="type-select" data-component-id="${component.id}">
                                    ${getTypeOptions(getComponentType(component))}
                                </select>
                            </span>
                            <span class="page-info">${getPageName(component)}</span>
                        </div>
                    </div>
                    <div class="component-actions">
                        <button class="btn-action" onclick="navigateToComponent('${component.id}', '${getPageName(component)}')">
                            👁️ View
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Update filter button states
            updateFilterButtons(filter);
        }
        
        // Filter components based on criteria
        function filterComponents(components, filter) {
            switch (filter) {
                case 'unknown':
                    return components.filter(c => {
                        const type = getComponentType(c);
                        return !type || type === 'unknown';
                    });
                case 'low':
                    return components.filter(c => c.confidence < 0.5);
                case 'verified':
                    return components.filter(c => c.isVerified);
                case 'all':
                default:
                    return components;
            }
        }
        
        // Update filter button states
        function updateFilterButtons(activeFilter) {
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-filter') === activeFilter) {
                    btn.classList.add('active');
                }
            });
        }
        
        // Navigate to component in Figma
        function navigateToComponent(componentId, pageName) {
            console.log('👁️ Navigating to component:', componentId, pageName);
            
            parent.postMessage({
                pluginMessage: {
                    type: 'navigate-to-component',
                    componentId: componentId,
                    pageName: pageName
                }
            }, '*');
            
            showStatus(`📍 Navigating to component: ${componentId}`, 'info');
        }
        
        // Set up filter button event listeners
        function setupFilterButtons() {
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const filter = btn.getAttribute('data-filter');
                    console.log('🔍 Filter selected:', filter);
                    
                    if (globalScanResults.length > 0) {
                        displayComponents(globalScanResults, filter);
                    }
                });
            });
        }
        
        // Set up search input event listener
        function setupSearchInput() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const searchQuery = e.target.value.toLowerCase().trim();
                    console.log('🔎 Search query:', searchQuery);
                    
                    if (globalScanResults.length > 0) {
                        const filteredComponents = searchQuery ? 
                            globalScanResults.filter(c => 
                                c.name.toLowerCase().includes(searchQuery) ||
                                getComponentType(c).toLowerCase().includes(searchQuery)
                            ) : globalScanResults;
                        
                        displayComponents(filteredComponents, currentFilter);
                    }
                });
            }
        }
        
        // Handle successful UI generation
        function handleGenerationSuccess(msg) {
            console.log('🔄 handleGenerationSuccess called, resetting button...');
            const generateBtn = document.getElementById('generateBtn');
            const generationStatus = document.getElementById('generationStatus');
            const jsonDebugSection = document.getElementById('jsonDebugSection');
            const jsonOutput = document.getElementById('jsonOutput');
            
            // Enter iteration mode
            enterIterationMode(msg.generatedJSON, msg.frameId);
            
            // Show success status
            if (generationStatus) {
                generationStatus.innerHTML = '<div class="status success">✅ UI generated successfully! You can now iterate on it.</div>';
            }
            
            // Show generated JSON if available
            if (msg.generatedJSON && jsonOutput && jsonDebugSection) {
                jsonOutput.textContent = JSON.stringify(msg.generatedJSON, null, 2);
                jsonDebugSection.style.display = 'block';
            }
            
            // Show validation info if available
            if (msg.validationResult) {
                console.log('📊 Validation result:', msg.validationResult);
            }
            
            showStatus('🎉 UI generated successfully! Ready for iteration.', 'success');
        }
        
        // Global iteration state
        let iterationState = {
            isIterating: false,
            originalJSON: null,
            currentJSON: null,
            frameId: null,
            history: []
        };
        
        // Enter iteration mode after successful generation
        function enterIterationMode(generatedJSON, frameId) {
            console.log('🔄 Entering iteration mode with frameId:', frameId);
            
            iterationState = {
                isIterating: true,
                originalJSON: JSON.parse(JSON.stringify(generatedJSON)),
                currentJSON: generatedJSON,
                frameId: frameId,
                history: ['Original design generated']
            };
            
            // Update UI elements for iteration mode
            const generateBtn = document.getElementById('generateBtn');
            const userPrompt = document.getElementById('userPrompt');
            const userPromptLabel = document.getElementById('userPromptLabel');
            
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = '🪄 Apply Changes';
                console.log('✅ Generate button updated for iteration mode');
            }
            
            if (userPrompt) {
                userPrompt.value = '';
                userPrompt.placeholder = 'e.g., "add a forgot password link" or "change the button to secondary"';
            }
            
            if (userPromptLabel) {
                userPromptLabel.textContent = 'Describe the changes you want to make:';
            }
            
            // Show iteration context
            showIterationContext();
            
            console.log('✅ Iteration mode activated');
        }
        
        // Show iteration context UI
        function showIterationContext() {
            const iterationContext = document.getElementById('iterationContext');
            const currentDesignName = document.getElementById('currentDesignName');
            const modHistory = document.getElementById('modHistory');
            
            if (iterationContext) {
                iterationContext.style.display = 'block';
            }
            
            if (currentDesignName && iterationState.currentJSON) {
                const designName = iterationState.currentJSON.layoutContainer?.name || 'Generated UI';
                currentDesignName.textContent = designName;
            }
            
            if (modHistory && iterationState.history) {
                modHistory.innerHTML = iterationState.history
                    .map(item => `<li>${item}</li>`)
                    .join('');
            }
        }
        
        // Start fresh - reset iteration mode
        function startFresh() {
            console.log('🔄 Starting fresh - resetting iteration mode');
            
            iterationState = {
                isIterating: false,
                originalJSON: null,
                currentJSON: null,
                frameId: null,
                history: []
            };
            
            // Update UI elements
            const generateBtn = document.getElementById('generateBtn');
            const userPrompt = document.getElementById('userPrompt');
            const userPromptLabel = document.getElementById('userPromptLabel');
            const iterationContext = document.getElementById('iterationContext');
            
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = '🪄 Generate UI';
            }
            
            if (userPrompt) {
                userPrompt.value = '';
                userPrompt.placeholder = 'create a login form with email and password fields...';
            }
            
            if (userPromptLabel) {
                userPromptLabel.textContent = 'Describe the UI you want to create:';
            }
            
            if (iterationContext) {
                iterationContext.style.display = 'none';
            }
            
            console.log('✅ Fresh mode activated');
        }
        
        // Handle successful UI modification
        function handleModificationSuccess(msg) {
            console.log('🔄 handleModificationSuccess called');
            console.log('📊 Modification result:', msg);
            
            const generateBtn = document.getElementById('generateBtn');
            const generationStatus = document.getElementById('generationStatus');
            const userPrompt = document.getElementById('userPrompt');
            
            // Enhanced validation checking with detailed logging
            if (msg.validationResult) {
                console.log('📊 Detailed validation result:', {
                    isValid: msg.validationResult.isValid,
                    score: msg.validationResult.score,
                    errorCount: msg.validationResult.errors?.length || 0,
                    warningCount: msg.validationResult.warnings?.length || 0,
                    errors: msg.validationResult.errors?.map(e => `${e.code}: ${e.message}`) || [],
                    warnings: msg.validationResult.warnings?.map(w => `${w.code}: ${w.message}`) || []
                });
                
                // If validation failed significantly, log issues and abort update
                const criticalIssues = msg.validationResult.errors?.filter(e => e.severity === 'critical') || [];
                if (!msg.validationResult.isValid && criticalIssues.length > 0) {
                    console.error('❌ Modification validation failed with critical issues, aborting update');
                    console.error('🐛 Critical issues:', criticalIssues);
                    
                    // Reset button and show error
                    if (generateBtn) {
                        generateBtn.disabled = false;
                        generateBtn.textContent = '🪄 Apply Changes';
                    }
                    
                    const errorMsg = criticalIssues[0]?.message || 'Critical validation failure';
                    showStatus(`❌ Modification failed: ${errorMsg}`, 'error');
                    return;
                }
                
                // Allow modifications with minor issues to proceed
                if (!msg.validationResult.isValid && msg.validationResult.score < 0.4) {
                    console.warn('⚠️ Modification has significant issues but proceeding...');
                    console.warn('🐛 Issues:', msg.validationResult.errors);
                }
            }
            
            // Store the change request before clearing prompt
            const changeRequest = userPrompt?.value.trim() || 'Changes applied';
            
            // Enhanced JSON validation with property checking
            if (msg.modifiedJSON) {
                console.log('📝 Validating modified JSON structure...');
                
                // Deep validation of the modified JSON to catch undefined properties
                const validationIssues = validateModifiedJSON(msg.modifiedJSON, iterationState.currentJSON);
                if (validationIssues.length > 0) {
                    console.warn('⚠️ JSON structure issues detected:', validationIssues);
                    // Continue but with warning
                    showStatus(`⚠️ Changes applied with ${validationIssues.length} structure warnings`, 'warning');
                } else {
                    console.log('✅ JSON structure validation passed');
                }
                
                // Update iteration state
                console.log('📝 Updating iteration state with new JSON');
                iterationState.currentJSON = msg.modifiedJSON;
                iterationState.history.push(changeRequest);
                
                // Debug: Log critical properties to verify they exist
                console.log('🔍 Validating component properties in new JSON...');
                const componentCount = countComponentsWithProperties(msg.modifiedJSON);
                console.log(`🔍 Found ${componentCount.total} components, ${componentCount.withProperties} have properties, ${componentCount.withValidIds} have valid IDs`);
                
                // Update UI
                showIterationContext();
            } else {
                console.error('❌ No modifiedJSON in response!');
                showStatus('❌ Modification failed - no JSON returned', 'error');
                return;
            }
            
            // Reset generate button
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = '🪄 Apply Changes';
                console.log('✅ Generate button reset after modification');
            }
            
            // Clear prompt and show success
            if (userPrompt) {
                userPrompt.value = '';
            }
            
            if (generationStatus) {
                const hasIssues = msg.validationResult && (!msg.validationResult.isValid || msg.validationResult.score < 0.8);
                const statusClass = hasIssues ? 'warning' : 'success';
                const statusText = hasIssues ? 
                    `⚠️ Changes applied with validation issues (score: ${Math.round((msg.validationResult?.score || 0) * 100)}%)` : 
                    '✅ Changes applied successfully!';
                generationStatus.innerHTML = `<div class="status ${statusClass}">${statusText}</div>`;
            }
            
            showStatus('✅ Changes applied successfully!', 'success');
        }
        
        // Validate modified JSON for structural issues
        function validateModifiedJSON(modifiedJSON, originalJSON) {
            const issues = [];
            
            try {
                // Check if it's valid JSON structure
                if (!modifiedJSON || typeof modifiedJSON !== 'object') {
                    issues.push('Modified JSON is not a valid object');
                    return issues;
                }
                
                // Check required structure
                if (!modifiedJSON.items && !modifiedJSON.layoutContainer) {
                    issues.push('Missing required items or layoutContainer');
                }
                
                // Deep check for undefined properties
                const undefinedProps = findUndefinedProperties(modifiedJSON);
                if (undefinedProps.length > 0) {
                    issues.push(`Found undefined properties: ${undefinedProps.join(', ')}`);
                }
                
                // Check if component IDs are preserved where they should be
                const originalIds = extractAllComponentIds(originalJSON);
                const modifiedIds = extractAllComponentIds(modifiedJSON);
                
                // Allow for additions/removals but check for corrupted IDs
                const corruptedIds = modifiedIds.filter(id => id && (id.includes('undefined') || id === 'undefined'));
                if (corruptedIds.length > 0) {
                    issues.push(`Found corrupted component IDs: ${corruptedIds.join(', ')}`);
                }
                
            } catch (error) {
                issues.push(`JSON validation error: ${error.message}`);
            }
            
            return issues;
        }
        
        // Find undefined properties in JSON recursively
        function findUndefinedProperties(obj, path = 'root') {
            const undefinedProps = [];
            
            if (obj && typeof obj === 'object') {
                for (const [key, value] of Object.entries(obj)) {
                    if (value === undefined) {
                        undefinedProps.push(`${path}.${key}`);
                    } else if (value && typeof value === 'object') {
                        if (Array.isArray(value)) {
                            value.forEach((item, index) => {
                                undefinedProps.push(...findUndefinedProperties(item, `${path}.${key}[${index}]`));
                            });
                        } else {
                            undefinedProps.push(...findUndefinedProperties(value, `${path}.${key}`));
                        }
                    }
                }
            }
            
            return undefinedProps;
        }
        
        // Extract all component IDs from JSON
        function extractAllComponentIds(json) {
            const ids = [];
            
            function traverse(obj) {
                if (obj && typeof obj === 'object') {
                    if (obj.componentNodeId) {
                        ids.push(obj.componentNodeId);
                    }
                    if (Array.isArray(obj.items)) {
                        obj.items.forEach(traverse);
                    }
                    if (obj.layoutContainer) {
                        traverse(obj.layoutContainer);
                    }
                }
            }
            
            traverse(json);
            return ids;
        }
        
        // Count components and their properties for validation
        function countComponentsWithProperties(json) {
            let total = 0;
            let withProperties = 0;
            let withValidIds = 0;
            
            function traverse(obj) {
                if (obj && typeof obj === 'object') {
                    if (obj.type && obj.type !== 'layoutContainer') {
                        total++;
                        
                        if (obj.properties && typeof obj.properties === 'object') {
                            withProperties++;
                        }
                        
                        if (obj.componentNodeId && obj.componentNodeId.match(/^[0-9]+:[0-9]+$/)) {
                            withValidIds++;
                        }
                    }
                    
                    if (Array.isArray(obj.items)) {
                        obj.items.forEach(traverse);
                    }
                    if (obj.layoutContainer) {
                        traverse(obj.layoutContainer);
                    }
                }
            }
            
            traverse(json);
            return { total, withProperties, withValidIds };
        }
        
        // Handle UI generation error
        function handleGenerationError(error) {
            console.log('🔄 handleGenerationError called, resetting button...');
            const generateBtn = document.getElementById('generateBtn');
            const generationStatus = document.getElementById('generationStatus');
            
            // Reset generate button with appropriate text
            if (generateBtn) {
                generateBtn.disabled = false;
                if (iterationState.isIterating) {
                    generateBtn.textContent = '🪄 Apply Changes';
                } else {
                    generateBtn.textContent = '🪄 Generate UI';
                }
                console.log('✅ Generate button reset after error');
            } else {
                console.error('❌ Generate button not found in error handler!');
            }
            
            // Show error status
            if (generationStatus) {
                generationStatus.innerHTML = `<div class="status error">❌ Generation failed: ${error}</div>`;
            }
            
            showStatus(`❌ Generation failed: ${error}`, 'error');
        }
        
        // Helper functions
        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / (1000 * 60));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return 'recently';
        }
        
        function getConfidenceLevel(confidence) {
            if (confidence >= 0.8) return 'high';
            if (confidence >= 0.5) return 'medium';
            return 'low';
        }
        
        function getTypeOptions(selectedType) {
            const commonTypes = [
                'button', 'input', 'card', 'list-item', 'text', 'image', 'icon',
                'tab', 'navbar', 'modal', 'dialog', 'checkbox', 'radio', 'switch',
                'snackbar', 'alert', 'fab', 'chip', 'avatar', 'badge', 'header',
                'appbar', 'breadcrumb', 'pagination', 'slider', 'progress', 'skeleton',
                'divider', 'spacer', 'container', 'frame', 'grid', 'select', 'textarea'
            ];
            
            // Always include the selected type even if it's not in our common list
            const allTypes = selectedType && !commonTypes.includes(selectedType) 
                ? [...commonTypes, selectedType].sort()
                : commonTypes;
            
            return allTypes.map(type => 
                `<option value="${type}" ${type === selectedType ? 'selected' : ''}>${type}</option>`
            ).join('');
        }
        
        // Get page name from component - handle different property names
        function getPageName(component) {
            return component.pageName || 
                   component.page || 
                   component.pageTitle || 
                   component.parentPage ||
                   component.location ||
                   'Unknown page';
        }
        
        // Get component type - handle different property names
        function getComponentType(component) {
            const type = component.suggestedType || 
                         component.type || 
                         component.componentType ||
                         component.detectedType ||
                         component.category ||
                         'unknown';
            
            // Debug logging for first few components
            if (component.name && component.name.includes('snackbar')) {
                console.log('🔍 Type detection for', component.name, ':', {
                    suggestedType: component.suggestedType,
                    type: component.type,
                    resolved: type
                });
            }
            
            return type;
        }
        
        // Design System functions - connect to real implementation
        window.scanDesignSystem = function() {
            console.log('🔍 Scan Design System called');
            
            // Send message to backend
            parent.postMessage({
                pluginMessage: { type: 'scan-design-system' }
            }, '*');
            
            // Update UI
            const scanBtn = document.getElementById('scanBtn');
            if (scanBtn) {
                scanBtn.disabled = true;
                scanBtn.textContent = '🔍 Scanning...';
            }
            
            showStatus('🔄 Scanning design system...', 'info');
        };
        
        window.rescanDesignSystem = function() {
            console.log('🔄 Re-scan Design System called');
            window.scanDesignSystem(); // Just call the main scan function
        };
        
        window.generateLLMPrompt = function() {
            console.log('📋 Generate LLM Prompt called');
            showStatus('ℹ️ Prompt generation - Feature coming soon!', 'info');
        };
        
        // AI Generation functions - connect to real implementation
        window.generateWithGemini = function() {
            console.log('🪄 Generate with Gemini called');
            
            const userPrompt = document.getElementById('userPrompt');
            const generateBtn = document.getElementById('generateBtn');
            const generationStatus = document.getElementById('generationStatus');
            
            if (!userPrompt || !userPrompt.value.trim()) {
                showStatus('❌ Please enter a prompt to generate UI', 'error');
                return;
            }
            
            const prompt = userPrompt.value.trim();
            
            // Check if we're in iteration mode or fresh generation
            if (iterationState.isIterating) {
                console.log('🔄 Applying changes to existing design:', prompt);
                applyChangesToDesign(prompt, generateBtn, generationStatus);
            } else {
                console.log('🎯 Generating new UI for prompt:', prompt);
                generateNewDesign(prompt, generateBtn, generationStatus);
            }
        };
        
        // Generate completely new design
        function generateNewDesign(prompt, generateBtn, generationStatus) {
            // Update UI
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.textContent = '🪄 Generating...';
            }
            
            if (generationStatus) {
                generationStatus.innerHTML = '<div class="status info">🤖 Generating UI with AI...</div>';
            }
            
            // Debug: Log what components we actually have
            console.log('🔍 Available components for AI:', globalScanResults);
            
            // Build intelligent design system context (like the original)
            let availableComponentsInfo = '';
            if (globalScanResults && globalScanResults.length > 0) {
                availableComponentsInfo = buildIntelligentDesignSystemContext(globalScanResults);
            } else {
                availableComponentsInfo = `\n\nNO DESIGN SYSTEM SCANNED - Use native types only: native-rectangle, native-text, native-frame.`;
            }
            
            const systemPrompt = `You are a Senior UX Designer with deep knowledge of design systems and component libraries. Your task is to create Figma-compatible JSON that uses the user's actual design system components.

## Your UX Design Intelligence:
- When users ask for a "textfield", they want ANY component that handles text input
- When users ask for a "button", they want ANY component that handles actions/clicks
- When users ask for "text", they want ANY component that displays content
- When users ask for "container", they want ANY component that groups content

## Critical Rules:
1. RESPOND WITH ONLY JSON - NO explanations or markdown
2. Use EXACT structure with proper auto-layout:
   {
     "layoutContainer": {
       "name": "Your UI Name",
       "layoutMode": "VERTICAL",
       "width": 375,
       "paddingTop": 16,
       "paddingBottom": 16,
       "paddingLeft": 16,
       "paddingRight": 16,
       "itemSpacing": 12
     },
     "items": [...]
   }
3. ALWAYS use layoutMode "VERTICAL" for mobile layouts (unless specifically horizontal)
4. ALWAYS include padding and itemSpacing for proper auto-layout
5. Use EXACT componentNodeId values from the design system below
6. Apply UX reasoning to match user intent with available components

${availableComponentsInfo}

## Auto-Layout Requirements:
- layoutMode MUST be "VERTICAL" or "HORIZONTAL" (preferably "VERTICAL" for mobile)
- Always include paddingTop, paddingBottom, paddingLeft, paddingRight (typically 16)
- Always include itemSpacing (typically 8-16)
- Width should be 375 for mobile layouts

## Your UX Task:
Apply your design expertise to intelligently map the user's request to the most appropriate components from their design system. Ensure proper auto-layout structure and be creative but precise with componentNodeId values.`;
            
            // Send to backend
            parent.postMessage({
                pluginMessage: {
                    type: 'generate-ui-from-prompt',
                    payload: {
                        prompt: prompt,
                        systemPrompt: systemPrompt,
                        components: globalScanResults,
                        enableValidation: true
                    }
                }
            }, '*');
            
            addGenerationTimeout(generateBtn, '🪄 Generate UI');
        }
        
        // Apply changes to existing design (iteration mode)
        function applyChangesToDesign(changeRequest, generateBtn, generationStatus) {
            // Update UI
            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.textContent = '🪄 Applying...';
            }
            
            if (generationStatus) {
                generationStatus.innerHTML = '<div class="status info">🤖 Applying changes with AI...</div>';
            }
            
            // Enhanced analysis of current JSON structure for better preservation
            const currentStructureAnalysis = analyzeCurrentStructure(iterationState.currentJSON);
            console.log('🔍 Current structure analysis:', currentStructureAnalysis);
            
            // Build highly detailed modification prompt with explicit preservation instructions
            const systemPrompt = `You are a Senior UX Designer with expertise in precise JSON modifications. Your task is to apply ONLY the requested changes while preserving ALL unchanged elements with absolute precision.

## CRITICAL MODIFICATION RULES (ZERO TOLERANCE FOR ERRORS):
1. RESPOND WITH ONLY VALID JSON - NO explanations, markdown, or comments
2. **PRESERVE UNCHANGED ELEMENTS EXACTLY**: Every element not mentioned by the user MUST remain identical
3. **PRESERVE ALL COMPONENT IDS**: Use the EXACT same componentNodeId values for unchanged components
4. **PRESERVE ALL PROPERTIES**: For unchanged components, copy ALL properties exactly (text content, variants, layout settings)
5. **PRESERVE PROPERTY STRUCTURE**: Keep the exact same property names and values
6. **PRESERVE ARRAY ORDER**: Maintain the same order of items unless user specifically requests reordering
7. **PRESERVE AUTO-LAYOUT**: Keep layoutContainer structure with layoutMode, padding, and spacing EXACTLY as is

## CURRENT DESIGN ANALYSIS:
- Total components: ${currentStructureAnalysis.componentCount}
- Components with properties: ${currentStructureAnalysis.componentsWithProperties}
- Layout structure: ${currentStructureAnalysis.layoutStructure}
- Key component IDs to preserve: ${currentStructureAnalysis.keyComponentIds.join(', ')}

## Available Components for NEW additions only:
${globalScanResults && globalScanResults.length > 0 ? 
    buildIntelligentDesignSystemContext(globalScanResults) : 
    'Use native types: native-rectangle, native-text, native-frame'}

## CURRENT DESIGN JSON (PRESERVE EXACTLY unless user requests changes):
\`\`\`json
${JSON.stringify(iterationState.currentJSON, null, 2)}
\`\`\`

## USER'S SPECIFIC CHANGE REQUEST:
"${changeRequest}"

## MODIFICATION STRATEGY:
1. **COPY THE ENTIRE CURRENT JSON** as your starting point
2. **IDENTIFY ONLY THE SPECIFIC ELEMENTS** the user wants to change
3. **MAKE MINIMAL TARGETED CHANGES** to only those elements
4. **VERIFY ALL OTHER ELEMENTS** remain exactly the same
5. **DOUBLE-CHECK ALL COMPONENT IDS** are preserved correctly

## EXAMPLES OF WHAT TO PRESERVE:
- If current JSON has componentNodeId "123:456", keep it as "123:456"
- If current properties has {"text": "Login", "variants": {"State": "enabled"}}, preserve exactly
- If user doesn't mention a button, keep that button exactly as is
- If user doesn't mention layout, keep layoutContainer exactly as is

CRITICAL: Return the COMPLETE JSON structure with the user's changes applied but everything else preserved exactly.`;
            
            // Send modification request to backend
            parent.postMessage({
                pluginMessage: {
                    type: 'modify-ui-from-prompt',
                    payload: {
                        originalJSON: JSON.stringify(iterationState.currentJSON),
                        modificationRequest: changeRequest,
                        systemPrompt: systemPrompt,
                        frameId: iterationState.frameId,
                        enableValidation: true
                    }
                }
            }, '*');
            
            addGenerationTimeout(generateBtn, '🪄 Apply Changes');
        }
        
        // Analyze current JSON structure to help with preservation
        function analyzeCurrentStructure(json) {
            let componentCount = 0;
            let componentsWithProperties = 0;
            const keyComponentIds = [];
            let layoutStructure = 'unknown';
            
            function traverse(obj) {
                if (obj && typeof obj === 'object') {
                    if (obj.type && obj.type !== 'layoutContainer') {
                        componentCount++;
                        
                        if (obj.componentNodeId) {
                            keyComponentIds.push(obj.componentNodeId);
                        }
                        
                        if (obj.properties && typeof obj.properties === 'object') {
                            componentsWithProperties++;
                        }
                    }
                    
                    if (obj.layoutContainer && obj.layoutContainer.layoutMode) {
                        layoutStructure = obj.layoutContainer.layoutMode;
                    }
                    
                    if (Array.isArray(obj.items)) {
                        obj.items.forEach(traverse);
                    }
                    if (obj.layoutContainer) {
                        traverse(obj.layoutContainer);
                    }
                }
            }
            
            traverse(json);
            
            return {
                componentCount,
                componentsWithProperties,
                keyComponentIds: keyComponentIds.slice(0, 5), // Show first 5 IDs
                layoutStructure
            };
        }
        
        // Add timeout fallback
        function addGenerationTimeout(generateBtn, resetText) {
            setTimeout(() => {
                if (generateBtn && generateBtn.disabled && 
                    (generateBtn.textContent.includes('Generating') || generateBtn.textContent.includes('Applying'))) {
                    console.log('⚠️ Generation timeout, resetting button...');
                    generateBtn.disabled = false;
                    generateBtn.textContent = resetText;
                    showStatus('⚠️ Generation timeout - try again', 'error');
                }
            }, 90000);
        }
        
        window.generateFromJSON = function() {
            console.log('📄 Generate from JSON called');
            
            const jsonInput = document.getElementById('jsonInput');
            if (!jsonInput || !jsonInput.value.trim()) {
                showStatus('❌ Please enter JSON to generate UI', 'error');
                return;
            }
            
            try {
                const jsonData = JSON.parse(jsonInput.value.trim());
                console.log('📋 Generating UI from JSON');
                
                // Send to backend
                parent.postMessage({
                    pluginMessage: {
                        type: 'generate-ui-from-json',
                        payload: jsonData
                    }
                }, '*');
                
            } catch (error) {
                showStatus('❌ Invalid JSON format', 'error');
                console.error('JSON parse error:', error);
            }
        };
        
        window.copyGeneratedJSON = function() {
            console.log('📋 Copy Generated JSON called');
            showStatus('ℹ️ Copy JSON - Feature coming soon!', 'info');
        };
        
        window.toggleJSONView = function() {
            console.log('👁️ Toggle JSON View called');
            const jsonOutput = document.getElementById('jsonOutput');
            if (jsonOutput) {
                jsonOutput.style.display = jsonOutput.style.display === 'none' ? 'block' : 'none';
            }
        };
        
        // Intelligent Design System Context Builder (inspired by original approach)
        function buildIntelligentDesignSystemContext(components) {
            // Group components by UX purpose rather than rigid patterns
            const uxGroups = {
                'Input & Forms': [],
                'Actions & Navigation': [],
                'Content Display': [],
                'Layout & Structure': [],
                'Feedback & Status': []
            };
            
            components.forEach(comp => {
                const type = (comp.suggestedType || comp.type || '').toLowerCase();
                const name = (comp.name || '').toLowerCase();
                
                // Smart UX-based categorization
                if (type.includes('input') || type.includes('field') || type.includes('text') || 
                    name.includes('input') || name.includes('field') || name.includes('form')) {
                    uxGroups['Input & Forms'].push(comp);
                } else if (type.includes('button') || type.includes('link') || type.includes('nav') ||
                          name.includes('button') || name.includes('action') || name.includes('cta')) {
                    uxGroups['Actions & Navigation'].push(comp);
                } else if (type.includes('text') || type.includes('label') || type.includes('title') ||
                          type.includes('image') || name.includes('text') || name.includes('content')) {
                    uxGroups['Content Display'].push(comp);
                } else if (type.includes('card') || type.includes('container') || type.includes('frame') ||
                          name.includes('card') || name.includes('container') || name.includes('panel')) {
                    uxGroups['Layout & Structure'].push(comp);
                } else if (type.includes('alert') || type.includes('toast') || type.includes('status') ||
                          name.includes('notification') || name.includes('status')) {
                    uxGroups['Feedback & Status'].push(comp);
                } else {
                    // Put unclassified items in the most appropriate group based on common patterns
                    uxGroups['Content Display'].push(comp);
                }
            });
            
            let context = `\n## 🎨 YOUR DESIGN SYSTEM (${components.length} components)
As a UX expert, you understand these components serve different purposes. Use your intelligence to map user requests to the most appropriate components.

**CRITICAL SEMANTIC INTELLIGENCE RULES:**
- When user asks for "textfield", look for anything related to text input, forms, or data entry
- When user asks for "button", look for anything related to actions, CTAs, or navigation  
- When user asks for "text", look for anything related to content display, labels, or typography
- When user asks for "card", look for anything related to containers, panels, or content grouping
- USE YOUR UX KNOWLEDGE to find the closest semantic match - don't be rigid!

`;
            
            Object.entries(uxGroups).forEach(([groupName, groupComponents]) => {
                if (groupComponents.length > 0) {
                    context += `\n### ${groupName}\n`;
                    groupComponents.forEach(comp => {
                        context += `- **${comp.suggestedType || comp.type}** ("${comp.name}") → componentNodeId: "${comp.id}"\n`;
                        
                        // Add intelligence about what this component might be used for
                        const intelligence = getComponentIntelligence(comp);
                        if (intelligence) {
                            context += `  💡 Use for: ${intelligence}\n`;
                        }
                    });
                    context += '\n';
                }
            });
            
            context += `\n## 🧠 INTELLIGENT SEMANTIC MAPPING GUIDANCE:

**Think like a UX Designer:**
- "textfield" request? → Look in "Input & Forms" - use ANY component that handles text input
- "button" request? → Look in "Actions & Navigation" - use ANY component that triggers actions  
- "text" request? → Look in "Content Display" - use ANY component that shows text content
- "container" request? → Look in "Layout & Structure" - use ANY component that groups content

**Your goal**: Find the CLOSEST semantic match using UX reasoning, not exact string matching.
**Remember**: Use the exact componentNodeId values listed above. Be creative but precise.`;
            
            return context;
        }
        
        // Get intelligent suggestions for what a component might be used for
        function getComponentIntelligence(comp) {
            const type = (comp.suggestedType || comp.type || '').toLowerCase();
            const name = (comp.name || '').toLowerCase();
            
            // Smart semantic suggestions
            if (type.includes('input') || name.includes('input')) {
                return 'textfield, email field, password input, search box, any text entry';
            } else if (type.includes('button') || name.includes('button')) {
                return 'submit button, CTA, action button, navigation button, any clickable action';
            } else if (type.includes('text') || name.includes('text')) {
                return 'label, title, heading, body text, any text display';
            } else if (type.includes('card') || name.includes('card')) {
                return 'container, panel, content card, any content grouping';
            } else if (type.includes('list') || name.includes('list')) {
                return 'menu item, row, list entry, any repeated content';
            } else if (type.includes('nav') || name.includes('nav')) {
                return 'navigation, menu, tab, any navigation element';
            }
            
            return null; // No specific intelligence available
        }
        
        // Iteration control functions
        window.startFresh = startFresh;
        
        window.viewCurrentDesignJSON = function() {
            console.log('👁️ View Current Design JSON called');
            if (iterationState.isIterating && iterationState.currentJSON) {
                const jsonOutput = document.getElementById('jsonOutput');
                const jsonDebugSection = document.getElementById('jsonDebugSection');
                
                if (jsonOutput && jsonDebugSection) {
                    jsonOutput.textContent = JSON.stringify(iterationState.currentJSON, null, 2);
                    jsonDebugSection.style.display = 'block';
                    showStatus('📋 Current design JSON displayed', 'info');
                } else {
                    showStatus('❌ JSON display area not found', 'error');
                }
            } else {
                showStatus('❌ No current design to display', 'error');
            }
        };
        
        window.resetToOriginal = function() {
            console.log('🔄 Reset to Original called');
            if (iterationState.isIterating && iterationState.originalJSON && iterationState.frameId) {
                // Reset iteration state to original
                iterationState.currentJSON = JSON.parse(JSON.stringify(iterationState.originalJSON));
                iterationState.history = ['Original design generated', 'Reset to original'];
                
                // Send modification request with original JSON
                parent.postMessage({
                    pluginMessage: {
                        type: 'modify-existing-ui',
                        payload: {
                            modifiedJSON: iterationState.originalJSON,
                            frameId: iterationState.frameId
                        }
                    }
                }, '*');
                
                // Update UI
                showIterationContext();
                showStatus('🔄 Reset to original design', 'info');
            } else {
                showStatus('❌ No original design to reset to', 'error');
            }
        };
        
        // Basic stub functions for remaining features
        const stubFunctions = [
            'closeSessionModal', 'restoreSession', 'startNewSession', 'showAllSessions', 
            'closeAllSessionsModal', 'clearAllData', 'clearImageSelection'
        ];
        
        stubFunctions.forEach(funcName => {
            window[funcName] = function(...args) {
                console.log(`📝 ${funcName} called (basic implementation)`, args);
                showStatus(`ℹ️ ${funcName} - Feature coming soon!`, 'info');
            };
        });
        
        // Listen for messages from Figma backend
        window.addEventListener('message', (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;
            
            console.log('📨 Received from backend:', msg.type, msg);
            
            switch (msg.type) {
                case 'api-key-saved':
                    console.log('✅ API Key saved successfully');
                    const saveBtn = document.getElementById('saveBtn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = '💾 Save API Key';
                    }
                    showStatus('✅ API Key saved successfully!', 'success');
                    
                    // Enable AI Generator tab
                    const generatorTab = document.getElementById('generatorTab');
                    if (generatorTab) {
                        generatorTab.disabled = false;
                    }
                    break;
                    
                case 'api-test-result':
                    console.log('🔌 API test result:', msg.success, msg.error);
                    const testBtn = document.getElementById('testBtn');
                    if (testBtn) {
                        testBtn.disabled = false;
                        testBtn.textContent = '🔌 Test Connection';
                    }
                    
                    if (msg.success) {
                        showStatus('✅ API connection successful!', 'success');
                    } else {
                        const errorMsg = msg.error || 'Connection test failed';
                        console.error('❌ Detailed API error:', errorMsg);
                        showStatus(`❌ API test failed: ${errorMsg}`, 'error');
                    }
                    break;
                    
                case 'api-key-found':
                    console.log('🔑 API Key found in storage');
                    const apiKeyInput = document.getElementById('apiKey');
                    if (apiKeyInput) {
                        apiKeyInput.value = '●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●';
                        apiKeyInput.setAttribute('data-has-key', 'true');
                    }
                    
                    // Enable AI Generator tab
                    const genTab = document.getElementById('generatorTab');
                    if (genTab) {
                        genTab.disabled = false;
                    }
                    break;
                    
                case 'api-key-not-found':
                    console.log('🔑 No API Key found');
                    break;
                    
                case 'scan-completed':
                case 'scan-results':
                    console.log('🔍 Design system scan completed:', msg.components?.length || 0, 'components');
                    handleScanResults(msg.components, msg.scanTime);
                    break;
                    
                case 'saved-scan-loaded':
                    console.log('📂 Saved scan loaded:', msg.components?.length || 0, 'components');
                    handleScanResults(msg.components, msg.scanTime);
                    break;
                    
                case 'no-saved-scan':
                    console.log('📂 No saved scan found');
                    break;
                    
                case 'ui-generated-success':
                    console.log('🎉 UI generation successful:', msg);
                    handleGenerationSuccess(msg);
                    break;
                    
                case 'ui-modified-success':
                    console.log('🎉 UI modification successful:', msg);
                    handleModificationSuccess(msg);
                    break;
                    
                case 'ui-generation-error':
                    console.log('❌ UI generation failed:', msg.error);
                    handleGenerationError(msg.error);
                    break;
                    
                default:
                    console.log('📨 Unhandled message:', msg.type);
            }
        });
        
        // Request saved API key on load
        setTimeout(() => {
            parent.postMessage({
                pluginMessage: { type: 'get-api-key' }
            }, '*');
        }, 100);
        
        console.log('✅ Basic UI functions loaded and ready');
    </script>
</body>
</html>